# Introducing hyper63

A service-gateway for creating future-proof applications

## What does future-proof mean exactly?

Future-proof is designing your application architecture in such a way that when change comes your app is best suited to handle the change with minimum impact.

## What is a service-gateway?

A gateway is an API that provides one entry point for external requests and performs some checking then routes them to their destination. You may be thinking that sounds a lot like a proxy, yes, but a proxy does not change or maniupate or process the request, it simply moves it to the service unchanged, with a gateway the request is modified to adapt to a specific service. Or maybe they both mean the same thing :shrug:, but in this context the service gateway is providing a common specification for a given service.

The service side of the description, basically means that this product connects to multiple services, these services provide a specific implementation for your application. For example, data is a service that can be used to store and retrieve structured documents, (aka Database), or storage, which can be used to store and retrieve unstructured documents (aka S3 Buckets).

hyper63 is made up of services that perform useful functions, in your application, these services can have several adapters so that you can choose which implementation you want at a given time. For example, you may want to use MongoDb for your database, or you may want to use DynamoDb, and over time, you may need to change to a different adapter, for example Azure DocumentDB, hyper63 is designed to separate your application business logic from your service implementation, so switching from one sevice to another is a configuration change.

That is what is meant by future proof. By choosing hyper63 as your service-gateway, you can future-proof your application and make it easy to migrate from one technology to another technology over time.

## Trade-offs

Having said all of that, the great engineering minds maybe thinking, yeah but, what about this and what about that. Yes, with any system that adds constraints there will be tradeoffs, and you will want to decide, do you want a future proof application? It will make you think and make decisions differently.

But lets look at some scenarios

## Feature Complexity

- Sprinkle business rules in multiple layers of your application, a little in the database, a little in ui, a little in the server. Great, feature shipped! Enter pointy haired boss, thats great, but can you do x. Now you havae to go to the database and create a migration, you have go to the ui and modify all the components and you have to go to the server and update the api spec, then modify your validation rules then, change all the unit tests and end to end tests, then setup a full test environment, and finally document all of the changes for your team. Over time these rules begin to intertwine and it gets harder and harder to make a simple change. This is the current state of development, usually when the technical debt is reconized it is too late. You have to work through all the pain or beg for the ability to re-write.

This scenario is all too real and it takes a lot of displine to prevent this from happening. What if you could help with that displine by adding a boundary or barrier between your architecture layers. This boundary would make it challenging to spread your business rules from place to place. That is the goal of hyper63 to be the bad guy, to provide frustration when trying to do something that will shoot your future self in the foot.

## Lets take a look at the api!
